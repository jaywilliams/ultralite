<h3>Caching and Templating</h3>
<p>
By default, caching is turned off to avoid caching of content that may not require caching. Caching is turned on simply by using the setCaching() method.
</p

<div class="codebox">
<?php
$code = '
<?php
	/*** a new view instance ***/
	$view = new view;

	/*** turn caching on for this page ***/
	$view->setCaching(true);
?>';
echo highlight_string($code,1);
?>
</div>

<p>
The cache_id is set from the controller and is in the format of /path/filename.php/options.
</p>

<div class="codebox">
<?php
$code = '
<?php
	/*** the path to the template ***/
	$path =__APP_PATH . \'/views/index.php\';

	/*** a new view instance ***/
	$view = new view;

	/*** set the cache id ***/
	$view->cache_id = md5( $path );

	/*** fetch the template ***/
	$result = $view->fetch( $path );

	/*** a new front controller ***/
	$fc = FrontController::getInstance();

	/*** set the body ***/
	$fc->setBody($result);
?>';
echo highlight_string($code,1);
?>
</div>

<p>
To get add options, that may have been passed via the url or other source, it would be like this
</p>
<div class="codebox">
<?php
$code = '
<?php
/*** the path to the template ***/
$path =__APP_PATH . \'/views/index.php\';

	/*** a new uri instance ***/
	$uri = uri::getInstance();

	/*** get an option from the uri ***/
	$options = $uri->fragment(1);

/*** a new view instance ***/
$view = new view;

/*** set the cache id ***/
$view->cache_id = md5( $path );

/*** fetch the template ***/
$result = $view->fetch( $path.$options );

/*** a new front controller ***/
$fc = FrontController::getInstance();

/*** set the body ***/
$fc->setBody($result);
?>';
echo highlight_string($code,1);
?>
</div>

<h1>Logging</h1>
<p>

Logging is provided with the logging class. The logging class found in the application/libs/logging.class.php and contains a single static __call() method. This enables the coder to supply an unlimitted amount of logging calls.
</p>
</p>
<div class="codebox">
<?php
$code = '
<?php
logger::auditLog($message, 100, __FILE__, __LINE__ );
logger::errorLog($message, 200, __FILE__, __LINE__ );
logger::debugLog($message, 300, __FILE__, __LINE__ );
?>';
echo highlight_string($code,1);
?>
</div>
<p>
The above shows how diffent functions can be dynamically created to suit the needs of the developer. The second arguement is the log level. The log level is set in the application/config/config.ini.php file. Only those log messages with a log level lower than log level specified in the config file will be logged. This, of course, means if the log level is set to zero, no logging will occur, unless a log level is also set to zero, which should be avoided. There is no sane limit to the number of logging levels you may specify.
</p>
<p>
The log has the option to store the log in a database, or on the file system. If the file option is used, the file MUST exist on the file system and be writeable by the httpd server.
</p>
<p>
The log class configuration options in the logging section of the config.ini.php file are as follows
</p>
<dl>
<dt>log_level</dt>
<dd>The logging level. Only calls with a log level equal to, or below this level will be recored</dd>

<dt>log_handler</dt>
<dd>file</dd>
<dd>database</dd>

<dt>log_file</dt>
</dd>The absolute path to the log file. This file MUST be writable by the web server.</p>

